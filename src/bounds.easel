pub fn this.TeleportBoundsX([body, radius]) {
    on BeforePhysics {
        if body.Pos.X.Abs > radius + BOUNDS_RADIUS && body.Velocity.X.Sign == body.Pos.X.Sign {
            Pos = @(-body.Pos.X, body.Pos.Y)
        }
    }
}

pub fn this.DespawnBounds([body, radius]) {
    on BeforePhysics {
        if body.Pos.X.Abs > radius + BOUNDS_RADIUS {
            body.Expire
        } else if body.Pos.Y + radius > BOUNDS_RADIUS {
            body.Expire
        }
    }
}

pub fn this.DespawnBoundsY([body, radius]) {
    on BeforePhysics {
        if body.Pos.Y + radius > BOUNDS_RADIUS {
            body.Expire
        }
    }
}

pub fn this.CollideBounds([body, radius]) {
    on BeforePhysics {
        // bounce back 
        if body.Pos.Y.Abs > BOUNDS_RADIUS {
            // 6 is scale of the image sprite(3) * 2 (collision is 1)
            let offset = body.Pos.Y.Sign == 1 ? -6 : 6
            body.Pos = @(body.Pos.X, body.Pos.Y + offset)
        } else if body.Pos.Y.Abs + 3 > BOUNDS_RADIUS {
            // slow down verticle movement
            body.ApplyImpulse(@(0, body.Velocity.Y*-3))
        }
    }
}

pub fn RandomSpawnTopPos(radius=1) -> Vector {
    return @(Random * BOUNDS_RADIUS * PickRandom([1,-1]), -BOUNDS_RADIUS - radius)
}

pub fn RandomSpawnPos(radius=1) -> Vector {
    return @(Random * BOUNDS_RADIUS * PickRandom([1,-1]), Random * BOUNDS_RADIUS * PickRandom([1,-1]))
}