pub tangible category Category:Asteroid

prop asteroid.Health

pub fn asteroid.Asteroid(radius=RandomRange(2.5,5), pos=RandomSpawnTopPos(4), speed=10*Random, velocity=@(speed * Random * PickRandom([0.2,-0.2]), speed), health=50*RandomRange(2.5,5), collides=true, dissipate=0.75s, color=#dddddd, generation=0, parent?) {
    use body = asteroid
    use layer= collides ? 5 : -3
    use turnRate=0.01rev*PickRandom([-Random, Random])
    
    Health = health
    
    Body(pos=, velocity=)
    if collides {
        PolygonCollider(shape=Circle, category=Category:Asteroid)
    }

    const asteroidSprite = PickRandom([
        @assets/asteroid1.svg,
        @assets/asteroid2.svg,
        @assets/asteroid3.svg,
        @assets/asteroid4.svg,
        @assets/asteroid5.svg,
        @assets/asteroid6.svg,
        @assets/asteroid7.svg,
    ])
    ImageSprite(asteroidSprite, shading=0.25, shadow=0, color=color.Darken(Random - 0.8))
    
    RecoverSpeed
    DespawnBounds

    on BeforeCollide that {

        Health -= Settings[that.Category.ToString].damage
        
        const MaxGenerations = 2
        if Health <= 0 {
            repeat 15 { Spark(radius=radius*5, bodyOffset=Direction(that.Velocity)*-radius, feather=1, taper=0.1, layer=7, color=#333333, shine=0, splatter=1, dissipate=2s, radius=Random, velocity=Velocity*Direction(that.Velocity)*-1) }
            
            Expire
            if generation < MaxGenerations {
                let parent = asteroid
                let nextGen = generation + 1
                repeat 2 {
                    Spawn asteroid {
                        Asteroid(radius=0.6*radius, pos=Pos+RandomVector*3, speed=1.3*speed, health=health/nextGen, 
                                 dissipate=0.7*dissipate, generation=nextGen, parent=)
                    }
                }
            }
        } else {
            repeat 5 { Spark(radius=radius*3, bodyOffset=Direction(that.Velocity)*-radius, feather=1, taper=0.3, layer=7, color=#333333, shine=0, splatter=1, dissipate=0.8s, radius=Random, velocity=Velocity*Direction(that.Velocity)*-1) }
        }
    }
}
