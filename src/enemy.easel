pub tangible category Category:Enemy

pub symbol Drone
pub symbol Fighter
pub symbol Leader
pub symbol None

pub symbol StrategyCautious
pub symbol StrategyAggressive

symbol StateApproach
symbol StateHold
symbol StateAvoid
symbol StateRealign

prop ship.State

fn this.ChangeState(currentState, nextState) -> symbol {
    let resultState = nextState
    if nextState == StateHold {
        resultState = nextState
    } else if currentState == StateAvoid || currentState == StateApproach {
        resultState = currentState
    }
    return resultState
}

pub fn this.BehaveCatious(body, speed=3) {
        let lastDetectedPos = @(0,0)
        behavior on Tick(4) {
            
            let hero = QueryNearest(filter=Category:Ship)
            if !hero { 
                Heading = HALF_PI
                Velocity = @(0, 4)
                break 
            }
            Heading = lastDetectedPos - body.Pos
            let nextDetectedPos = lastDetectedPos.Towards(hero.Pos, 1)
            lastDetectedPos = nextDetectedPos == 1 ? hero.Pos : nextDetectedPos

            if lastDetectedPos == hero.Pos {
                await Tick(1.5s)
            }
            // let distanceFromHero = Distance(body.Pos, hero.Pos)
            // if body.state == StateApproach {            
            //         body.Velocity = lastDetectedPos * speed * 2
            // ConsoleLog(body.Velocity)
            //     // await Tick(1s + Random*1s)
            //     // Heading = hero.Pos - body.Pos
            // } else if body.state == StateAvoid {
            //     // let shipDirection = Direction(body.Velocity - hero.Velocity)
            //     body.Velocity *= -1
            // } else if body.state == StateHold {
            //     body.Velocity = @(0, 0)
            //     Heading = hero.Pos - body.Pos
            // }
            
        }

        behavior on Tick(20) {
            let hero = QueryNearest(filter=Category:Ship)
            if !hero { break }
            
            let distanceFromHero = Distance(body.Pos, hero.Pos).Abs
            if lastDetectedPos == @(0, 0) {
                lastDetectedPos = Direction(hero.Pos - body.Pos)
                Heading = hero.Pos - body.Pos
            }
            // let distanceAway = body.Pos.Towards(hero.Pos, 5)
            // if distanceAway != hero.Pos && body.state != StateApproach {
            if distanceFromHero > 40 && body.state != StateApproach {
                body.state = ChangeState(body.state, StateApproach)
                lastDetectedPos = Direction(hero.Pos - body.Pos)
                body.ApplyImpulse(Direction(lastDetectedPos)*155)
                // RecoverSpeed(speed=body.Velocity.Y)
                
            } else if distanceFromHero < 30 && body.state != StateAvoid {
                body.state = ChangeState(body.state, StateAvoid)
                // body.Velocity = lastDetectedPos * -2
                body.ApplyImpulse(Direction(hero.Pos - body.Pos)*-155)
            } else if distanceFromHero > 30 && distanceFromHero < 40 {
                body.state = ChangeState(body.state, StateHold)
                // let head = hero.Pos - body.Pos
                // let angleCheck = Direction(head).Dot(Direction(body.Heading)).Abs
                // ConsoleLog(angleCheck)
                // if angleCheck < 0.4 {
                //     ApplyTurningImpulse(24)
                // } else {
                //   ApplyTurningImpulse(-24)
                // }
                body.Velocity = @(0, 0)

            } 
            // else {
            //     body.state = ChangeState(body.state, StateRealign)
            //     let head = hero.Pos - body.Pos
            //     // let angleCheck = Direction(head).Dot(Direction(body.Heading)).Abs
            //     // if angleCheck > 0.4 {
            //     //     ApplyTurningImpulse(24)
            //     //     await Tick(2s)
            //     // } else {
            //     //     Heading = hero.Pos - body.Pos
            //     //     body.state = ChangeState(body.state, StateHold)
            //     // }
            // }
        }
}

pub fn ship.Enemy(
    type=None, 
    pos=RandomSpawnTopPos,
    health=1,
    fireRate=2s,
    killScore=50,
    dropRate=0.3,
    strategy=StrategyCautious,
    [owner]) {
    use body = ship
    use radius = 1
    // use speed = 8
    use layer = 5
    let state = StateApproach
    
    Health = health
    
    const maxHealth = health
    const lowHealth = maxHealth/3
    
    Body(pos=, velocity=@(0, 8))
    PolygonCollider(shape=Circle(3), category=Category:Enemy, density=1)

    if type == Drone {
        ImageSprite(@assets/enemy_fighter.png, color=#ee1111, shading=0.3, shadow=0, scale=4.5)
    } else if type == Fighter {
        ImageSprite(@assets/enemy_fighter.png, shading=0.3, shadow=0, scale=4.5)
    } else if type == Leader {
        ImageSprite(@assets/enemy_fighter.png, color=#eeee11, shading=0.3, shadow=0, scale=4)   
    } else {
        PolygonSprite(shape=Circle, color=#ff0000)        
    }

    TeleportBoundsX
    DespawnBoundsY

    once Tick {
       Heading = HALF_PI 
        // let hero = QueryNearest(filter=Category:Ship)
        // if hero {
        //     Heading = hero.Pos - body.Pos
        // }
    }

    // if strategy == StrategyCautious {

    // }

    on Tick(fireRate) {
        let hero = QueryNearest(filter=Category:Ship)
        if hero {
            Spawn projectile {
                Bomb(ship=, target=hero.Pos)
            }
        }
    }

    on BeforeCollide that {
        if that.Category.Overlaps(Category:Weapon | Category:Asteroid) {
            Strobe(shine=0.5, dissipate=0.5s)
            
            Health -= Settings[that.Category.ToString].damage

            if Health <= lowHealth {
                behavior<malfunction> on Tick(0.5s) {
                    repeat 7 { 
                        Spark(radius=Random*2, bodyOffset=RandomVector*radius, color=#222222, shine=0, splatter=1, fade=0.5, dissipate=1s, radius=Random, velocity=-Velocity) 
                    }
                    
                    repeat 4 {
                        Spark(radius=0.5, layer=6, dissipate=0.1s, color=#ffcc00, luminous=1, bloom=3, speed=30, velocity=RandomVector*40, splatter=1)
                    }

                    Velocity = Velocity + RandomVector*PickRandom([-2,2])
                }
            }
            
            if Health <= 0 {
                Hear(@assets/explosion2.mp3)
                
                repeat 10 {
                    Spark(radius=4, color=#fbec8e, luminous=1, bloom=3, feather=1, dissipate=0.75s, splatter=1, speed=10)
                }
                
                if Random > 1-dropRate {
                    Spawn powerup {
                        surprise {                
                            0.2 => Powerup(pos=Pos, type=EnergyShield),
                            0.2 => Powerup(pos=Pos, type=MultiLaser),
                            0.5 => Powerup(pos=Pos, type=HealthPickup),
                            0.2 => Powerup(pos=Pos, type=AddFireRate),
                        }
                    }
                }

                if that.Category == Category:Weapon {
                    owner.Score += killScore
                }
                
                Expire
                break
            }
        }
    }

    once BeforeDespawn {
        Explode
    }
}
